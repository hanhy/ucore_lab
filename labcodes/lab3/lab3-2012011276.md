# report

## [练习 0] 填写已有实验
本实验依赖实验1/2，请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。
```
>完成移植之后执行make qemu，出现了
page fault at 0x00000100: K/W [no page found]
考虑到这是由于没有处理缺页导致的，可认为已经移植成功。
```

## [练习 1] 给未被映射的地址映射上物理页(需要编程)
```
>
实现思路：
	根据实验课的介绍和自己的理解，在阅读了相应代码部分的注释之后，可以确定该函数的实现过程如下：
		查找PTE，如果这个PTE的PT(page table)不存在就创建一个PT
		如果该物理地址不存在，说明还没有分配物理页，可以调用pgdir_alloc_page为其分配，并建立映射关系。
		如果物理地址存在，就是已经分配过了页且该页在磁盘中
			检测swap_init_ok以确定是否进行正确的页置换算法
			如果swap_init_ok是0
				说明没有正确执行swap_init，返回错误信息
			如果swap_init_ok是1
				进行页置换
					调用swap_in函数，判断返回值（正确的返回值应该是0）
					如果不是0
						置换失败，返回错误信息
					如果是0
						调用page_insert函数为换入的页建立映射关系
						将换入的页置为swappable
与答案区别：
	基本类似，只是有一些细节实现上不同，另外在分配物理页的时候调用函数
	pgdir_alloc_page(mm->pgdir, addr, perm);没有判断分配失败的情况。
	在执行swap_in函数的时候也没有进行判定（虽然能够执行成功，但是鲁棒性应该比较差）
		代码1.0：
			   ptep = get_pte(mm->pgdir, addr, 1);//查找PTE，如果这个PTE的PT(page table)不存在就创建一个PT
								  //参数1的意义是不存在就创建一个
			   if(ptep != NULL && *ptep == 0){//正确执行了do_pgfault函数而且物理地址存在
					pgdir_alloc_page(mm->pgdir, addr, perm);
					//还没有分配物理页，那么调用pgdir_alloc_page函数分配页
			   }
			   else{
				if(ptep == NULL)
					goto failed;//执行do_pgfault函数出错
				if(!swap_init_ok)
					goto failed;
				//进行页置换
				struct Page *tempPage = NULL;
				swap_in(mm, addr, &tempPage);
				page_insert(mm->pgdir, tempPage, addr, perm);//建立映射
				swap_map_swappable(mm, addr, tempPage, 1);//新页设为swappable
			   }
	加上两个判定后就变成了最后的结果。
思考题：
	1.请描述页目录项(Pag	Director	Entry)和页表(Page	Table	Entry)中组成部分对ucore实现页替换算法的潜在用处
		页表项和页目录项尾部有一个标志位，标志位为1表示正常，页目录项前20位表示二级页表地址的前20位
		标志位为0，缺页，前24位表示缺页的扇区号。
	2.如果ucore的缺页服务例程在执行过程中访问内存,出现了页访问异常,请问硬件要做哪些事情?
		a.首先和其他异常类似，CPU存储当前的PC、EIP、错误码，压入栈，保存程序现场。然后将其的中断号(0xE)对应的缺页服务例程地址存储到CS和EIP中。
		b.处理异常中断
		c.恢复现场
```


## [练习2] 补充完成基于FIFO的页面替换算法(需要编程)
```
>
实现思路：
	根据实验课的介绍和自己的理解，在阅读了相应代码部分的注释之后，可以确定该函数的实现过程如下：
		map_swappable部分
			list_add(head, entry); 
			只需要将最近使用过的页插入到pra_list_head的头部
		swap_out_vistim部分
			换出最早进入队列的页，根据该双向链表的结构，应该在head的前一个项
			把这一页地址的地址传给参数ptr_page
与答案的不同：
	代码量很小，而且目标很明确，所以基本上是一样的，但是比起标准答案，没有两个assert的部分，这是不严密的地方，最终上交的版本已经加上了。
		
思考题：
	1.如果要在ucore上实现"extended clock页替换算法"请给你的设计方案,现有的swap_manager框架是否足以支持在ucore
	中实现此算法?如果是,请给你的设计方案。如果不是,请给出你的新的扩展和基此扩展的设计方案。并需要回答如下
	问题：
		需要被换出的页的特征是什么?
		在ucore中如何判断具有这样特征的页?
		何时进行换入和换出操作?
	是可以实现的，设计思路如下：
	可以。思路如下：
		设原来的clock算法中的访问位是A，由于存在这样的情况：有的页被访问过，但是没有被修改过，因此不需要拷贝进磁盘中，现在，我们在Page的
		结构中再设一个位B作为是否被修改过的标志，设B = 0 表示没有被修改过，然后我们重复如下的步骤知道找到能够替换的页（实际最多进行两遍）
		第一步：从开始位置循环扫描队列，寻找A=0、B=O的第一类面，找到立即置换。另外，第一次扫描期间不改变访问位A。
		第二步：如果第一步失败，则开始第二轮扫描，寻找A=0且B=1的第二类页面，找到后立即置换，并将所有扫描过的A都置0。
		第三步：如果第二步也失败，则返回指针开始位置，然后重复第一步，必要时再重复第二步，此时必能找到淘汰页。
	2.列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点。
		虚拟内存：扩大逻辑地址的手段，通过虚拟页管理、缺页、置换等把磁盘的一部分空间划分成“虚拟的”内存     
		局部性原理和局部置换算法以及缺页异常处理
	3.列出你认为OS原理中重要的知识点，但在实验中没有对应上
		LRU、最不常用置换算法、全局置换算法
```
