# report

## [练习 0] 填写已有实验
本实验依赖实验1/2/3，请把你做的实验1/2/3的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。

## [练习 1] 分配并初始化一个进程控制块(需要编程)
```
>
实现过程和思路：
	本题主要是初始化一个新进程的PCB，按照proc_struct中各元素的意义以及提示信息，依次给TCB中的各元素赋值即
	可，需要赋值的元素及其应该被赋予的初值及其对应的意义如下所示：
		state = PROC_UNINIT       新创建的进程还没有进行初始化
		pid = -1                  没有分配进程号
		runs = 0                  没有开始运行
		kstack = 0;               没有分配内核栈
		need_resched = 0;         没有占用CPU，亦不用被重新安排释放CPU资源
		parent = NULL;            没有确定的父进程
		mm = NULL;                存储空间还未确定
		context 内容全部置0       没有参与过进程切换，没有上下文的问题，内容全部置0
		tf = NULL;                没有发生过中断
		cr3 = boot_cr3;           由于是内核线程，置为虚拟空间页目录表首地址boot_cr3
		flags = 0;                标志位初始化为0，
		name 全部置0              还没有名字，全部置为0
与标准答案的区别
	因为是按照提示的顺序依次进行初始化操作，所以基本上跟答案是一样的，有一处不同————初始化name。我认为memset
	的第一个参数应该是一个指针，所以使用的是&(proc->name)（与context初始化相同），但是答案则是直接使用了proc
	->name，经过对比思考我认为这是由于name是一个char的数组，两种表达方式都是其首地址，是一样的。
思考题：
	请说明proc_struct中 struct context context 和 struct trapframe *tf 成员 变量含义和在本实验中的作用是啥？
	（提示通过看代码和编程调试可以判断出来）
	context是进程的上下文，其实内部保存的是一系列寄存器的值，用于在进程切换的时候保存上下文，便于恢复，switch_to
	函数（定义在switch.S中）由于涉及到进程切换，是context的主要使用者。
	tf是一个中断帧的指针，也是用于保存寄存器的值，用于在保存中断现场，并且在中断结束的时候恢复。
```
## [练习 2] 为新创建的内核线程分配资源(需要编程)
```
>
实现过程和思路：
	1. 调用alloc_proc分配一个TCB，若失败跳到fork_out，并将子进程的parent设为current（即当前进程，fork的源）
	2. 调用setup_kstack函数分配内核堆栈，若失败跳到bad_fork_cleanup_proc
	3. 调用copy_mm函数分配存储空间，若失败跳到bad_fork_cleanup_kstack
	4. 调用copy_thread函数设置trapframe、context和线程入口
	5. 先关中断，把新的内核线程添加到hash_list和proc_list，总线程数目加一，开中断
	6. 调用wakeup_proc函数唤醒该进程，即将其设为RUNNABLE
	7. 返回pid
与答案的不同之处：
	我刚开始写的时候前几步直接调用了函数就开始进行下一步，并没有判断返回值代码如下：
		proc = alloc_proc();
		proc->parent = current;
		setup_kstack(proc);
		copy_mm(clone_flags, proc)
		copy_thread(proc, stack, tf);
	运行之后有错误出现，参考了答案之后进行了一些判断步骤，最终的形态跟参考答案基本一致。
	另外在调试的过程中也使用过一些输出信息，最终结果已经注释掉了。
思考题:
	请说明ucore是否做到给每个新fork的线程一个唯一的id？ 请说明你的分析和理由。
	是的。
	do_fork函数在分配进程id的时候调用了get_pid函数，查看这个函数的实现细节可以发现，分配新的id的时候系统查找
	了整个proc_list以保证新进程的id与之前的任何进程都不同。
```
## [练习 3] 阅读代码，理解proc_run函数和它调用的函数如何完成进程切换的(无编码工作)
```
>
对proc_run函数的分析：
	proc_run函数首先查看需要切换到的进程proc是否正在运行，如果正在运行不作操作，否则进行切换，首先关闭中断，进行
	切换，最后开中断，切换过程可以分为如下几个步骤：
	1.当前进程设置为proc
	2.切换内核堆栈，即把当前栈顶指针esp0设置成proc的内核栈的栈顶
	3.页表的切换，即改变页目录表基址寄存器CR3的值为proc的cr3
	4.上下文的切换，即调用switch_to函数进行两个进程的上下文切换（实际是保存一系列寄存器的值）
在本实验的执行过程中， 创建且运行了几个内核线程？
	2个，分别是idleproc和initproc
语句 local_intr_save( intr_flag) ; . . . . local_intr_restore( intr_flag) ; 在这里有何作用?请说明理由	
	作用：
		开中断、关中断
	理由：
		进程切换的过程中不能被打断，所以在进程切换开始的时候清除irg中断标志位，进程切换完成之后恢复之。
```
## [其他] 
```
>
列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点
	1.进程控制块的各个元素的意义及其在进程运行中所起的作用
	2.进程的三状态模型
	3.进程的创建（fork的实现细节）、加载与切换
列出你认为OS原理中重要的知识点，但在实验中没有对应上
	进程的三状态模型并没有得到完全的实现
```
